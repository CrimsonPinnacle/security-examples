# Overview

This example demonstrates a homograph attack used to exploit certificates. The [IDN homograph attack](https://en.wikipedia.org/wiki/IDN_homograph_attack) is well know attack used to exploit internationalized domain names (IDNs). The same approach can be used to deceive users of certificates.

More details on how this attack can impact secure software supply chains is available in [Signatures, Key Management, and Trust in Software Supply Chains – Part 2: Exploiting Signatures](#)

## How the files are generated?

The following section describes the commands used to generate the files.

### Generating the real signature

The files used for the *real* signature are saved in the `real` folder. The only two files you need are:

- [`real-cert-data.conf`](real/real-cert-data.conf) that contains the configuration for the generation of the *real* key and certificate.
- [`artifact.txt`](real/artifact.txt) which is the *artifact* that we will sign. This file is exactly the same as the file with the same name in the `fake` folder.

The steps involved are:

1. Generate the *private key* and the *certificate signing request* using the following command:
  ```
  openssl req -utf8 -nameopt multiline,utf8 -config real-cert-data.conf -new -sha256 -newkey rsa:4096 -nodes -keyout real-key.pem -days 730 -out real-req.pem
  ```
  This command uses the data from the [`real-cert-data.conf`](real/real-cert-data.conf) configuration file. The validity of the request will be 730 days or two years. This command generates the following two files:
  - [`real-key.pem`](real/real-key.pem) that contains the generated *private key* and
  - [`real-req.pem`](real/real-req.pem) that contains the *certificate signing request*
2. Use the following command to check the *certificate signing request*'s *Subject*:
  ```
  openssl req -text -nameopt lname,utf8 -in real-req.pem -noout | grep Subject:
  ```
3. The following command *self-signs* the *certificate signing request*:
  ```
  openssl x509 -req -nameopt lname,utf8 -days 730 -in real-req.pem -signkey real-key.pem -out real-cert.crt
  ```
  The result of this command will be the [`real-cert.crt`](real/real-cert.crt) file that contains the *real* certificate.
4. View the *Subject* and the *Issuer* of the self-signed certificate with the following commands:
  ```
  openssl x509 -nameopt lname,utf8 -in real-cert.crt -text -noout | grep Subject:
  openssl x509 -nameopt lname,utf8 -in real-cert.crt -text -noout | grep Issuer:
  ```
  The output from these commands is the following:
  ```
        Subject: countryName=US, stateOrProvinceName=WA, localityName=Seattle, organizationName=Toddy Mladenov, commonName=toddysm.com, emailAddress=me@toddysm.com
        Issuer: countryName=US, stateOrProvinceName=WA, localityName=Seattle, organizationName=Toddy Mladenov, commonName=toddysm.com, emailAddress=me@toddysm.com
  ```
5. Sign the [`artifact.txt`](real/artifact.txt) using the private key stored in [`real-key.pem`](real/real-key.pem) file using the following command:
  ```
  openssl dgst -sign real-key.pem -keyform PEM -sha256 -out artifact-real.sign -binary artifact.txt
  ```
  This will generate the [`artifact-real.sign`](real/artifact-real.sign) file that contains the signature for the artifact.
6. Extract the *public key* used to verify the *signature* using the following command:
  ```
  openssl x509 -in real-cert.crt -noout -pubkey -out real-cert.pub
  ```
  This will generate the file [`real-cert.pub`](real/real-cert.pub) that contains the *public key* used to verify the *signature*.
7. Verify the *signature* using the following command:
  ```
  openssl dgst -verify real-cert.pub -keyform PEM -sha256 -signature artifact-real.sign -binary artifact.txt
  ```
  The output from the command should be: `Verified OK`

### Generating the forged (or fake) signature

The files used for the *forged* signature are saved in the `fake` folder. The only two files you need are:

- [`fake-cert-data.conf`](fake/fake-cert-data.conf) that contains the configuration for the generation of the *real* key and certificate.
- [`artifact.txt`](fake/artifact.txt) which is the *artifact* that we will sign. This file is exactly the same as the file with the same name in the `real` folder.

The steps involved are:

1. Generate the *private key* and the *certificate signing request* using the following command:
  ```
  openssl req -utf8 -nameopt multiline,utf8 -config fake-cert-data.conf -new -sha256 -newkey rsa:4096 -nodes -keyout fake-key.pem -days 730 -out fake-req.pem
  ```
  This command uses the data from the [`fake-cert-data.conf`](fake/fake-cert-data.conf) configuration file. The validity of the request will be 730 days or two years. This command generates the following two files:
  - [`fake-key.pem`](fake/fake-key.pem) that contains the generated *private key* and
  - [`fake-req.pem`](fake/fake-req.pem) that contains the *certificate signing request*
2. Use the following command to check the *certificate signing request*'s *Subject*:
  ```
  openssl req -text -nameopt lname,utf8 -in fake-req.pem -noout | grep Subject:
  ```
3. The following command *self-signs* the *certificate signing request*:
  ```
  openssl x509 -req -nameopt lname,utf8 -days 730 -in fake-req.pem -signkey fake-key.pem -out fake-cert.crt
  ```
  The result of this command will be the [`fake-cert.crt`](fake/fake-cert.crt) file that contains the *real* certificate.
4. View the *Subject* and the *Issuer* of the *self-signed certificate* with the following commands:
  ```
  openssl x509 -nameopt lname,utf8 -in fake-cert.crt -text -noout | grep Subject:
  openssl x509 -nameopt lname,utf8 -in fake-cert.crt -text -noout | grep Issuer:
  ```
  The output from these commands is the following:
  ```
        Subject: countryName=US, stateOrProvinceName=WA, localityName=Seattle, organizationName=Tоddу Mlаdеnоv, commonName=tоddуsm.com, emailAddress=me@toddysm.com
        Issuer: countryName=US, stateOrProvinceName=WA, localityName=Seattle, organizationName=Tоddу Mlаdеnоv, commonName=tоddуsm.com, emailAddress=me@toddysm.com
  ```
  Visually this output is the same as the one in Step 4. from [Generating the real signature](#generating-the-real-signature).
5. Sign the [`artifact.txt`](fake/artifact.txt) using the private key stored in [`fake-key.pem`](fake/fake-key.pem) file using the following command:
  ```
  openssl dgst -sign fake-key.pem -keyform PEM -sha256 -out artifact-fake.sign -binary artifact.txt
  ```
  This will generate the [`artifact-fake.sign`](fake/artifact-fake.sign) file that contains the signature for the artifact.
6. Extract the *public key* used to verify the *signature* using the following command:
  ```
  openssl x509 -in fake-cert.crt -noout -pubkey -out fake-cert.pub
  ```
  This will generate the file [`fake-cert.pub`](fake/fake-cert.pub) that contains the *public key* used to verify the *signature*.
7. Verify the *signature* using the following command:
  ```
  openssl dgst -verify fake-cert.pub -keyform PEM -sha256 -signature artifact-fake.sign -binary artifact.txt
  ```
  The output from the command should be: `Verified OK`
